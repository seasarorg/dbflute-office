<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja" >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta name="keywords" content="DBFlute,タスク,Task,Doc,LoadDataReverse,データエクセルテンプレート,エクセルデータの土台,エクセルデータの雛形,エクセルデータのひな形,データダンプ,Dump" />
	<style type="text/css" title="currentStyle">@import "../../../../../../css/sub.css";</style>
	<title>LoadDataReverse | DBFlute</title>
</head>
<body>
<div id="container" class="ct-manual">
<div id="mainbar"><div id="header">
	<a href="#">DBFlute<span>DB変更に強いO/Rマッパー</span></a>
	<img src="../../../../../../image/logo-content.gif" alt="logo"/>
	<ul>
		<li class="hd-introduction"><a href="#">Introduction</a></li>
		<li class="hd-tutorial"><a href="#">Tutorial</a></li>
		<li><ul><li class="hd-architect"><a href="#">for Architect</a></li><li class="hd-developer"><a href="#">for Developer</a></li></ul></li>
		<li class="hd-environment"><a href="#">Environment</a></li>
		<li><ul><li class="hd-install"><a href="#">Install</a></li><li class="hd-upgrade"><a href="#">Upgrade</a></li></ul></li>
		<li class="hd-manual"><a href="#">Manual</a></li>
	</ul>
</div>

<div id="content"><!-- __content-start__ -->
	<h1>LoadDataReverse</h1>
	<p>
		Alto DBFlute のパートです。
	</p>
	<div class="relatedpage"><a href="../../../../../introduction/altodbflute.html">Alto DBFlute</a></div>
	${indexlist}

	<h2 id="about">LoadDataReverseとは？</h2>
	<p>
		DB上の(一部の)データをエクセルやTSVなどのデータファイルとして出力する機能です<span class="freecomment">(@since 0.9.8.4)</span>。
	</p>
	<p>
		主に以下の二つの目的があります。
	</p>
	<ul>
		<li><em class="keyword">エクセル形式でデータベースのデータを閲覧する</em></li>
		<li><em class="keyword">ReplaceSchema のデータ登録で利用するエクセルデータの土台を作成する</em></li>
	</ul>
	<h3 id="notdump">厳密なデータダンプではない</h3>
	<p>
		<em class="keyword">この機能は、本番の業務データの移行などで利用できるデータダンプ(DataDump)ではありません</em>。
		人の目で見る、もしくは、手動での調整を入れて ReplaceSchema
		におけるエクセルデータの土台にする、という目的のものです。
		もし、業務の一環としてのデータダンプを目的とするなら、もっとデータの精密度を高めたり、もっと色々な状況に対応できるようにしたりする必要があるでしょう。
	</p>
	<h3 id="lreverseimage">LoadDataReverse概念図</h3>
	<p class="imgbox">図 : LoadDataReverse概念図
		<a href="../../../../../data/model/doc-LoadDataReverse-view.png" title="LoadDataReverse概念図"><img src="../../../../../data/model/doc-LoadDataReverse-view.png" alt="LoadDataReverse概念図" width="550" height="330" /></a>
	</p>

	<h2 id="howto">利用方法</h2>
	<h3 id="recordlimit">出力レコード数の設定</h3>
	<p>
		documentDefinitionMap.dfprop の loadDataReverseMap の recordLimit に出力レコード数(例えば、10 や -1 など)を設定し、Manageタスクで
		LoadDataReverse を実行すると(<span class="freecomment">@since 0.9.9.7B</span>)、DBFluteクライアント/output/doc/data
		配下に reverse-data-[セクション番号]-xxx.xls という形式の名前で出力されます。
	</p>
	<div class="relatedpage"><a href="../../../../reference/dfprop/documentdefinition/index.html#loaddatareversemap">dfprop - loadDataReverseMap</a></div>
	<div class="relatedpage"><a href="../manage/index.html">Manageタスク</a></div>
<pre><span class="codetitle">e.g. Manageタスクで LoadDataReverse の実行 (シェル) @Command</span><code>
<span class="abbreviation">...</span>$ <span class="keyword">sh</span> manage.sh load-data-reverse

 or

<span class="abbreviation">...</span>$ <span class="keyword">sh</span> manage.sh   <span class="comment">// Enter, and then select the number</span>
</code></pre>
	<h3 id="resultdfmark">出力結果の確認ドキュメント</h3>
	<p>
		実行すると、エクセルデータの出力ディレクトリに reverse-data-result.dfmark
		というファイルが作成されます。どのエクセルファイルに、どのテーブルのデータがどれだけ出力されたかなどの出力結果が記載されています。
		その他、出力日時や実行時のプロパティ情報、ReplaceSchema直接利用時のDateAdjustmentの同期処理の結果など、様々な情報を確認することができます。
	</p>
	<h3 id="backuplatest">一つ前の出力結果をバックアップ</h3>
	<p>
		実行すると、出力ディレクトリ配下の既存のエクセルファイルは全て削除された上でデータが出力されます。
		念のため、それら削除されるエクセルファイルを ZIP に固めたファイルを "出力ディレクトリ/backup"
		ディレクトリ配下に latest-data.zip という名前で保存します。実行するたびに、この ZIP
		ファイル自体を上書きしていきますので、二世代前のものは保存されません。
	</p>
	
	<h3 id="usehistory">利用方法の歴史的変遷</h3>
	<p>
		機能が発展していく中で、利用方法がちょっとずつ変わってきた歴史があります。
	</p>
	<dl class="textlist">
		<dt>0.9.9.7A 以前ではDocタスクにて <span class="freecomment">(@until 0.9.9.7A)</span></dt>
		<dd>
			0.9.9.7A 以前では、Manageタスクでの実行ではなく、プロパティの設定を有効にしてDocタスクを実行すると LoadDataReverse が実行されました。
		</dd>
		<dt>1.0.4A 以前ではプロパティ名が違う <span class="freecomment">(@until 1.0.4A)</span></dt>
		<dd>
			1.0.4A 以前では、playsqlに直接出力するプロパティ isReplaceSchemaDirectUse が、isOutputToPlaySql
			となっていました。ちなみに、既存のエクセルファイルに上書きや、DateAdjustment
			の基準日の同期などのオプションは、このプロパティ名の変更と共にサポートされた機能です。
			このとき、一気に LoadDataReverse が現場フィットするように改良されました。
		</dd>
		<dt>1.0.4A 以前では共通カラムはオプション <span class="freecomment">(@until 1.0.4A)</span></dt>
		<dd>
			1.0.4A 以前では、デフォルトでは共通カラムは出力されません<span class="freecomment">(@until 1.0.4A)</span>。
			共通カラムを出力したい場合は、documentDefinitionMap.dfprop の loadDataReverseMap の isContainsCommonColumn <span class="freecomment">(@until 1.0.4A)</span> を true にします。
		</dd>
		<dd>
			1.0.4B 以降では、<span class="existscloset">共通カラムは必ず出力されます。</span>
			共通カラムを除外するメリットが現場の利用状況を想定したときにあまりないと判断されたためです。
		</dd>
	</dl>

	<h2 id="replaceschema">ReplaceSchemaのデータとして</h2>
	<p>
		例えば、まだ ReplaceSchema を導入してない(データベース上にしかテストデータがない)状態から、
		ReplaceSchema でのテストデータ管理に移行するような場合に、この機能が多いに活躍するでしょう。
	</p>
	<p>
		また、既に ReplaceSchema を導入している場面でも、アプリ画面経由で登録したデータをエクセルデータとして利用したい場合にも有効です。
		既にアプリが信頼できる状態なら、ReplaceSchemaのテストデータを増やすためにも LoadDataReverse
		が活躍します(テストデータの循環運用が可能)。
	</p>
	<div class="relatedpage"><a href="#cyclicdata">this - 循環テストデータ運用</a></div>
	<h3 id="playsqloutput">playsql 配下に出力</h3>
	<p>
		ReplaceSchemaでそのまま利用することが前提にある場合は、ReplaceSchema で利用する playsql
		ディレクトリ配下に直接出力することができます。documentDefinitionMap.dfprop の loadDataReverseMap の isReplaceSchemaDirectUse <span class="freecomment">(@since 1.0.4B)</span>
		を true にします。
	</p>
	<div class="relatedpage"><a href="../../../../reference/dfprop/documentdefinition/index.html#loaddatareversemap">dfprop - loadDataReverseMap</a></div>
	<dl class="textlist">
		<dt>出力先ディレクトリ</dt>
		<dd><em class="keyword">DBFluteクライアント/playsql/data/[現在のdataLoadingType]/reversexls</em></dd>
		<dd>※dataLoadingTypeは、デフォルトでは ut</dd>
		<dt>ファイル名</dt>
		<dd><em class="keyword">cyclic-data-[セクション番号]-xxx.xls</em></dd>
	</dl>
	<p>	
		reversexls ディレクトリ <span class="freecomment">(@since 1.0.4B)</span> に出力されます。これは、通常の xls
		ディレクトリとは違い、TSVやCSVのデータ登録よりも先に実行されるエクセルデータの配置領域です。
	</p>
	<div class="relatedpage"><a href="../replaceschema/loadxls.html#xlsfiledir">データ登録(エクセル) - エクセルファイルの配置</a></div>
	<h3 id="alldatatarget">全てのデータを対象に</h3>
	<p>
		限られたデータだけの出力だとFK制約で落ちる可能性があるため、ReplaceSchema
		のデータとして利用する場合は、基本的には全てのデータを対象とした方が良いため、recordList はマイナス値 "-1"
		にすることが推奨されます。
	</p>
	<h3 id="exceptcommon">commonのテーブルは出力対象外</h3>
	<p>
		common配下のエクセルデータに存在するテーブルは、ReplaceSchemaの直接利用を想定したときに不要と思われるため出力されません。
		(出力してしまうと、重複したデータとなってしまう)
	</p>
	<h3 id="fkorder">FK順序の考慮</h3>
	<p>
		ReplaceSchemaのエクセルデータの土台のためという目的を考慮して、FK順序を "ある程度"
		考慮して順番でテーブルのデータが出力されます。完全に厳密ではありませんが、単純な関連であればそのままの順番で
		ReplaceSchema に適用できるでしょう。
	</p>
	<div class="relatedpage"><a href="#loaddatareverse">this - LoadDataReverse</a></div>
	<p>
		FK制約違反が発生する場合は、手動でエクセルの順序を調整する必要があります。
	</p>
	<h3 id="largename">長いテーブル名の考慮</h3>
	<p>
		エクセルのシート名に利用できる文字数に、(約)30文字までという制限があります。
		それを超えるテーブル名がある場合は、ReplaceSchema の長いテーブル名対応の機能に沿った tableNameMap.dataprop
		を生成します。その場合のシート名は DBFlute が決め打った仮の名前になっているので、これを土台にする場合は手動で微調整すると良いでしょう。
	</p>
	<div class="relatedpage"><a href="../replaceschema/loadxls.html#tablenamemap">エクセルデータ - エクセルシート名制限回避の設定(dataprop)</a></div>
	<h3 id="reflargedata">ラージデータの考慮</h3>
	<p>
		エクセルの一つのセルに格納できる文字数に、(約)32,767文字までという制限があります。
		それを超えるカラムデータがある場合は、別シートに分割して出力されます。ReplaceSchema では、その分割されたデータは結合されて登録されます。
		<span class="freecomment">(@since 1.0.5C)</span>
	</p>

	<h2 id="cyclicdata">循環テストデータ運用</h2>
	<p>
		アプリ画面経由でデータベースに登録したデータを LoadDataReverse、ReplaceSchema
		のデータとし手動でデータ微調整しつつ複数のディベロッパーで共有し、とあるときまたアプリ画面経由でデータ登録して LoadDataReverse
		して...というような、テストデータをエクセルファイルとデータベースで循環させてテストケースを増やしていく <em class="keyword">循環テストデータ運用</em>
		で LoadDataReverse を活用できます。
	</p>
	<ol>
		<li>通常の ReplaceSchema 運用 <span class="freecomment">(最低限のテストデータを準備)</span></li>
		<li>アプリ画面でデータ登録</li>
		<li>LoadDataReverse</li>
		<li>通常の ReplaceSchema 運用 <span class="freecomment">(増えたデータをディベロッパーに共有)</span></li>
		<li>アプリ画面でデータ登録</li>
		<li>LoadDataReverse</li>
		<li>...</li>
	</ol>
	<p>
		整合性のとれたテストデータを手動で作成していくのは大変な作業です。
		既に信頼できるアプリの画面があるのであれば、その画面で登録したデータをエクセルにできれば、効率的にテストケースを増やしていけます。
		アプリが完璧でないにしても、出力後に人が目視で確認して業務的な微調整をすれば良いでしょう。それは同時にアプリの動作レビューにもなります。
	</p>
	<h3 id="overrideexisting">既存のエクセルファイルに上書きオプション</h3>
	<p>
		LoadDataReverseで出力したデータがそのまま手動調整なしで ReplaceSchema
		で登録できれば一番ですが、必ずしもそうできるとは限らないので、出力後に手動で微調整が必要かもしれません。
		また、エクセルファイルの構成(テーブルの定義位置やエクセルファイル名)を人のわかりやすい構成に直したいものです。
		ただ、手動調整しても、デフォルトでは出力時に DBFlute が自動構成されたもので上書きされてしまいます。
	</p>
	<p>
		手動調整後、手動で調整された既存のエクセルファイルの構成のままデータ出力したい場合は、
		isOverrideExistingDataFile を true にすると、既存の構成がキープされます。FK順序の調整は完全に人に委ねられたと言える状態になります。
		また、既存のエクセルに存在しないテーブルは、unknown
		という名前の付いたファイルに一律出力されますので、出力後に手動でいい感じに調整します。
	</p>
	<div class="relatedpage"><a href="../../../../reference/dfprop/documentdefinition/index.html#loaddatareversemap">dfprop - loadDataReverseMap</a></div>
	<p>
		ただし、まだDB変更が多い段階では手動調整のコストが高くなるので、調整の必要なく循環ができるのであれば、しばらくはこのオプションは使わない方がよいでしょう。
		どのエクセルにどのテーブルが出力されたかは、reverse-data-result.dfmark を見ればわかりますので。
	</p>
	<h3 id="synchronizeorigindate">DateAdjustmentの基準日の同期オプション</h3>
	<p>
		データ登録制御 (loadingControlMap.dataprop) の相対的な日付調整における基準日を、自動的に同期することができます。
		日付調整を利用している場合、LoadDataReverse すると調整された後のデータがエクセルデータとして出力されます。
		よって、基準日は LoadDataReverse を実行した日付にするのがベストであると言えます。isSynchronizeOriginDate
		を true に設定すると、基準日が実行した日付に修正され、実行のたびにつどつど手動で修正する必要がなくなります(修正忘れもなくなる)。
	</p>
	<div class="relatedpage"><a href="../replaceschema/loadxls.html#dateadjustment">ReplaceSchema - datapropにて相対値の指定 (DateAdjustment)</a></div>
	<p>
		同期処理の結果は、LoadDataReverse
		を実行したときに作成される出力結果の確認ドキュメント(reverse-data-result.dfmark)に記載されるので、
		本当に同期されたかどうかを確認したいときは、そのファイルを見ると良いでしょう。
	</p>
	<div class="relatedpage"><a href="#resultdfmark">this - 出力結果の確認ドキュメント</a></div>

	<h2 id="largedata">大量件数のデータの場合</h2>
	<h3 id="overexcel">エクセルの最大行数を超えた場合</h3>
	<p>
		DBFluteがサポートしているエクセルの最大行数が 655xx なので、出力最大レコード数を 65000
		と決め打ちで絞っています。もし、それを超える件数のデータが入っていて、かつ、recordLimit
		をそれ以上に設定した場合は、別途 TSV
		データとして出力されます<span class="freecomment">(@since 0.9.8.3)</span>。TSVファイルは、reversetsv
		ディレクトリに出力されます<span class="freecomment">(@since 1.0.4B)</span>。(1.0.4Bより前のバージョンでは、tsvに出力されます)
	</p>
	<p>
		TSV データへの出力は、一件ずつのフェッチ式になっているため、大量件数でもメモリ不足になることは基本的にありません。
	</p>
	<h3 id="manydata">全体的に行数が多い場合</h3>
	<p>
		逆に、エクセルの最大行数を超えていない場合で、全体的なテーブルの累積行数が多いとメモリ不足になる可能性があります。
		<span class="freecomment">(エクセルへの書き込みはライブラリの都合上、フェッチ式になっていないため)</span>
	</p>
	<p>
		その場合、タスクのメモリ設定を調整することで実行できるようになる可能性がありますが、
		基本的には LoadDataReverse そのような大容量のデータを落とすための機能ではありません。
	</p>
	<div class="relatedpage"><a href="../index.html#memory">DBFluteタスク - タスクのメモリ設定</a></div>

	<h2 id="spec">細かい仕様</h2>
	<p>
		細かい仕様を把握して、どのような調整を行えば良いのか判断していきましょう。
	</p>
	<dl class="textlist">
		<dt>バイナリ型のデータは全て null で出力</dt>
		<dd>バイナリ型のデータはサポートされず、全て null として出力されます。</dd>
		<dd>
			テストデータとして必要な場合は、手動で準備します。
			<div class="relatedpage"><a href="../replaceschema/loaddata.html#binary">データ登録 - バイナリデータの登録</a></div>
		</dd>
		<dt>JDBCタスクで取得されるテーブルが対象</dt>
		<dd>
			自動生成対象外(JDBCタスクの時点で対象外)となっているテーブルのデータは出力されません。
			そのテーブルのデータも出力したい場合は、一時的にそのテーブルも自動生成対象にする必要があります。
			<div class="relatedpage"><a href="../../../../reference/dfprop/databaseinfo/index.html">databaseInfoMap.dfprop</a></div>
		</dd>
		<dt>ビュー(VIEW)は対象外</dt>
		<dd>
			ビュー(VIEW)はデータ出力対象外です。
			当然のことと言えば当然ですが、ビューをシノニムの代わりに使っているような場合は、
			この機能を利用するときだけ一時的にその参照先テーブルを自動生成対象にする必要があります。
		</dd>
		<dt>追加スキーマのテーブルは対象外</dt>
		<dd>
			AdditionalSchema で定義されている追加スキーマのテーブルは対象外です。
			そもそも ReplaceSchema で取り扱うスキーマはメインスキーマであることが基本なためです。
		</dd>
		<dt>シノニム(SYNONYM)は出力される</dt>
		<dd>
			シノニム(SYNONYM)はデータ出力対象です。ただし、シノニムが自動生成対象になっていることが前提です。
			シノニムの参照先テーブルも自動生成対象となっている場合は、重複してデータが出力されますので、手動調整でどちらか片方を削除する必要があります。
		</dd>
		<dt>FK制約の順序考慮は厳密ではない</dt>
		<dd>
			テーブル間で複雑な参照関係を持っている場合に、FK制約の順序考慮が厳密にならない可能性があります。
			その場合は、手動でエクセルのシートの順序を変えたり、エクセルファイル構成を変えたりと調整する必要があります。
		</dd>
		<dt>厳密な精度は保証されない</dt>
		<dd>例えば、日付型は以下のような形式で出力されます。</dd>
		<dd>
			<ul class="supplementlist">
				<li>DATE : yyyy/MM/dd <span class="freecomment">(Oracleは HH:mm:ss も追加)</span></li>
				<li>TIMESTAMP : yyyy/MM/dd HH:mm:ss.SSS</li>
				<li>TIME : HH:mm:ss</li>
			</ul>
		</dd>
		<dd>
			もし、TIMESTAMP型がこの書式を超える細かい精度を持っていると、その精度は失われます。
		</dd>
		<dd>
			その他の型は、単なるJDBCドライバの時点で文字列に変換したものを利用します。
			JDBCドライバや文字列に直した時の特徴的な仕様によって、精度が失われる可能性はあります。
		</dd>
		<dd>
			これら精度を厳密に移行したい場合は、手動で調整する必要があります。
			また、あくまでテストデータの移行というのを大前提としているので、実業務の本番データの移行などでは利用できません。
		</dd>
		<dt>その他、メジャーでない型はサポートされない</dt>
		<dd>
			例えば、PostgreSQL の OID 型など、取扱いの難しいものなどはサポートされません。
			明示的にサポートしていないわけではなく、そういった型がある場合、単にJDBCドライバの時点で文字列に変換したものが出力されます。
			よって、JDBCドライバがその文字列を再解析できる場合は、ReplaceSchema でその文字列のままで登録できるかもしれません。
		</dd>
	</dl>
<!-- __content-end__ --></div></div>

<div id="sidebar">
	<ul>
		<li><a href="#">Under Construction</a></li>
	</ul>
</div>
<div id="footer">
	<ul>
		<li><a href="#">SiteMap</a></li>
		<li><a href="https://www.seasar.org/issues/browse/DBFLUTE">BTS</a></li>
		<li><a href="http://d.hatena.ne.jp/jflute">Author's Blog</a></li>
	</ul>
</div>
</div>
</body>
</html>