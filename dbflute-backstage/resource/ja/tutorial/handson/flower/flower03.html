<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja" >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta name="keywords" content="DBFlute,チュートリアル,ハンズオン,hands-on" />
	<style type="text/css" title="currentStyle">@import "../../../../css/sub.css";</style>
	<title>模範解答的なセクション 3 | DBFlute</title>
</head>
<body>
<div id="container" class="ct-manual">
<div id="mainbar"><div id="header">
	<a href="#">DBFlute<span>DB変更に強いO/Rマッパー</span></a>
	<img src="../../../../../image/logo-content.gif" alt="logo"/>
	<ul>
		<li class="hd-introduction"><a href="#">Introduction</a></li>
		<li class="hd-tutorial"><a href="#">Tutorial</a></li>
		<li><ul><li class="hd-architect"><a href="#">for Architect</a></li><li class="hd-developer"><a href="#">for Developer</a></li></ul></li>
		<li class="hd-environment"><a href="#">Environment</a></li>
		<li><ul><li class="hd-install"><a href="#">Install</a></li><li class="hd-upgrade"><a href="#">Upgrade</a></li></ul></li>
		<li class="hd-manual"><a href="#">Manual</a></li>
	</ul>
</div>

<div id="content"><!-- __content-start__ -->
	<h1>模範解答的なセクション 3</h1>
	${indexlist}

	<h2 id="overview">概要</h2>
	<p>
		DBFluteハンズオン、セクション 3 の模範解答的な実装です。
	</p>
	<p>
		正解は一つではありませんので、あくまで "的な" というところで、参考までに。
	</p>

	<h2 id="stakeholder">このセクションでの登場人物</h2>
<pre><span class="codetitle">e.g. このセクションでの登場人物 @Directory</span><code>
dbflute-hands-on
 |-src/test/java
 |  |-org.docksidestage.handson
 |  |  |-exercise
 |  |  |  |-<span class="spotlight"><span class="point">HandsOn03Test.java</span></span>
 |  |  |
 |  |  |-unit
 |-src/main/java
 |-<span class="abbreviation">...</span>
</code></pre>

	<h2 id="flowerimpl">模範解答的な実装</h2>
<pre><span class="codetitle">e.g. 模範解答的な実装やってみた @Java</span><code>
/**
 * @author jflute
 */
public class HandsOn03Test extends UnitContainerTestCase {

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    @Resource
    protected MemberBhv memberBhv;
    @Resource
    protected MemberSecurityBhv memberSecurityBhv;
    @Resource
    protected PurchaseBhv purchaseBhv;

    // ===================================================================================
    //                                                                     Exercise 1 to 3
    //                                                                     ===============
    /**
     * [1] 会員名称がSで始まる1968年1月1日以前に生まれた会員を検索
     * o 会員ステータスも取得する
     * o 生年月日の昇順で並べる
     * o 会員が1968/01/01以前であることをアサート
     * o "以前" の解釈は、"その日ぴったりも含む" で。
     * ※もし、よければ HandyDate を使ってみましょう。
     */
    public void test_1() throws Exception {
        // ## Arrange ##
        LocalDate targetDate = new HandyDate("1968/01/01").getLocalDate(); // HandyDateの紹介

        // ## Act ##
        ListResultBean&lt;Member&gt; memberList = memberBhv.selectList(cb -> {
            cb.query().setMemberName_LikeSearch("S", op -> op.likePrefix());
            cb.query().setBirthdate_LessEqual(targetDate);
            cb.query().addOrderBy_Birthdate_Asc();
        });

        // ## Assert ##
        assertHasAnyElement(memberList);
        memberList.forEach(member -> {
            LocalDate birthdate = member.getBirthdate();
            log(member.getMemberName(), birthdate);
            assertTrue(birthdate.isBefore(targetDate) || birthdate.isEqual(targetDate));

            // << いろいろなやり方がある >>
            assertFalse(birthdate.isAfter(targetDate));
            assertTrue(new HandyDate(birthdate).isLessEqual(targetDate));
        });
    }

    /**
     * [2] 会員ステータスと会員セキュリティ情報も取得して会員を検索
     * o 若い順で並べる。生年月日がない人は会員IDの昇順で並ぶようにする
     * o 会員ステータスと会員セキュリティ情報が存在することをアサート
     * ※カージナリティを意識しましょう
     */
    public void test_2() throws Exception {
        // ## Arrange ##
        // ## Act ##
        ListResultBean&lt;Member&gt; memberList = memberBhv.selectList(cb -> {
            cb.setupSelect_MemberStatus();
            cb.setupSelect_MemberSecurityAsOne();
        });

        // ## Assert ##
        // 会員から会員ステータスは、NotNullのFKカラムで参照しているので、探しにいけば必ず存在する
        // 会員から会員セキュリティは、FKの方向と探しにいく方向が逆なので同じ理論にはなりませんが、
        // ERDのリレーション線に注目。会員退会情報と比べると一目瞭然、黒丸がついていないので必ず存在する1
        //   会員から会員セキュリティ => 1:必ず1 (1:1)
        //   会員から会員退会情報    => 1:いないかもしれない1 (1:0..1)
        // ただ、物理的な制約はありません。業務的というのは、そういうルールにしているいうことだけなんですね。
        // 細かいですが、これがデータベースプログラミングにおいて、とても重要なんですよね。
        // ぜひ、カージナリティに着目してみてください。
        assertHasAnyElement(memberList);
        memberList.forEach(member -> {
            assertTrue(member.getMemberStatus().isPresent());
            assertTrue(member.getMemberSecurityAsOne().isPresent());
        });
    }

    /**
     * [3] 会員セキュリティ情報のリマインダ質問で2という文字が含まれている会員を検索
     * o 会員セキュリティ情報のデータ自体は要らない
     * o リマインダ質問に2が含まれていることをアサート
     * o アサートするために別途検索処理を入れても誰も文句は言わない
     * ※Actでの検索は本番でも実行されることを想定して、テスト都合でパフォーマンス劣化させないように
     * ※実装できたら、こんどはアサートのための検索の回数が一回になるようにしてみましょう(もし、複数回検索しているのであれば)。
     * また、それもできたら、会員名称とリマインダ質問を会員ごとに一行のログに出力してみましょう。
     */
    public void test_3() throws Exception {
        // ## Arrange ##
        String keyword = "2";

        // ## Act ##
        ListResultBean&lt;Member&gt; memberList = memberBhv.selectList(cb -> {
            cb.query().queryMemberSecurityAsOne().setReminderQuestion_LikeSearch(keyword, op -> op.likeContain());
        });

        // ## Assert ##
        assertHasAnyElement(memberList);

        // << べたべたパターン: ループの中で検索してるのがちょっとよくない >>
        memberList.forEach(member -> {
            memberSecurityBhv.selectByPK(member.getMemberId()).alwaysPresent(security -> {
                String question = security.getReminderQuestion();
                log(member.getMemberName(), question);
                assertTrue(question.contains(keyword));
            });
        });

        // << SQLを救出パターン >>
        // IDの抽出、stream()でこう書ける
        //List&lt;Integer&gt; memberIdList = memberList.stream().map(member -> {
        //    return member.getMemberId();
        //}).collect(Collectors.toList());
        // でも、ExtractColumnを使うのが一番
        ListResultBean&lt;MemberSecurity&gt; securityList = memberSecurityBhv.selectList(cb -> {
            cb.query().setMemberId_InScope(memberBhv.extractMemberIdList(memberList));
        });
        memberList.forEach(member -> {
            securityList.forEach(security -> {
                if (member.getMemberId().equals(security.getMemberId())) {
                    String question = security.getReminderQuestion();
                    log(member.getMemberName(), question);
                    assertTrue(question.contains(keyword));
                    markHere("exists");
                    // あっ、breakできない!?
                }
            });
            assertMarked("exists");
        });

        // << Mapにしちゃうパターン!? >>
        // Mapの作り方、collect()が使えるけど、今までのやり方でも Lambda 使えばそれなりにいいかんじ!?
        //Map<Integer, MemberSecurity> securityMap = newHashMap();
        //securityList.forEach(security -> securityMap.put(security.getMemberId(), security));
        Map<Integer, MemberSecurity> securityMap =
                securityList.stream().collect(Collectors.toMap(bean -> bean.getMemberId(), bean -> bean));
        memberList.forEach(member -> {
            MemberSecurity security = securityMap.get(member.getMemberId());
            String question = security.getReminderQuestion();
            log(member.getMemberName(), question);
            assertTrue(question.contains(keyword));
        });
    }

    // ===================================================================================
    //                                                                     Exercise 4 to 6
    //                                                                     ===============
    /**
     * [4] 会員ステータスの表示順カラムで会員を並べて検索
     * o 会員ステータスの "表示順" カラムの昇順で並べる
     * o 会員ステータスのデータ自体は要らない
     * o その次には、会員の会員IDの降順で並べる
     * o 会員ステータスのデータが取れていないことをアサート
     * o 会員が会員ステータスごとに固まって並んでいることをアサート
     */
    public void test_4() throws Exception {
        // ## Arrange ##
        // ## Act ##
        ListResultBean&lt;Member&gt; memberList = memberBhv.selectList(cb -> {
            cb.query().queryMemberStatus().addOrderBy_DisplayOrder_Asc();
            cb.query().addOrderBy_MemberId_Desc();
        });

        // ## Assert ##
        assertHasAnyElement(memberList);

        // << forEach()使ってみたパターン >>
        Set&lt;String&gt; statusSet = new HashSet&lt;String&gt;();
        Stack&lt;Member&gt; mbStack = new Stack&lt;Member&gt;();
        memberList.forEach(member -> {
            assertFalse(member.getMemberStatus().isPresent());
            String previous = !mbStack.isEmpty() ? mbStack.peek().getMemberStatusCode() : null;
            String current = member.getMemberStatusCode();
            log(previous, current);
            if (previous != null && !previous.equals(current)) {
                assertFalse(statusSet.contains(current));
            }
            statusSet.add(current);
            mbStack.add(member);
        });

        // << 普通のfor文のパターン >>
        statusSet.clear(); // ちと再利用させて
        String previous = null;
        for (Member member : memberList) {
            assertFalse(member.getMemberStatus().isPresent());
            String current = member.getMemberStatusCode();
            log(previous, current);
            if (previous != null && !previous.equals(current)) {
                assertFalse(statusSet.contains(current));
            }
            statusSet.add(current);
            previous = current;
        }

        // << というか、違うやり方 >>
        statusSet.clear(); // また再利用させて
        previous = null; // こっちも
        int switchCount = 0;
        for (Member member : memberList) {
            assertFalse(member.getMemberStatus().isPresent());
            String current = member.getMemberStatusCode();
            log(previous, current);
            if (previous != null && !previous.equals(current)) {
                ++switchCount;
            }
            statusSet.add(current);
            previous = current;
        }
        assertEquals(statusSet.size(), switchCount);
    }

    /**
     * [5] 生年月日が存在する会員の購入を検索
     * o 会員名称と会員ステータス名称と商品名も一緒に取得(ログ出力)
     * o 購入日時の降順、購入価格の降順、商品IDの昇順、会員IDの昇順で並べる
     * o OrderBy がたくさん追加されていることをログで確認すること
     * o 購入に紐づく会員の生年月日が存在することをアサート
     * ※ログ出力は、スーパークラスの log() メソッドが利用できる。可変長引数でカンマ区切り出力になる。
     */
    public void test_5() throws Exception {
        // ## Arrange ##
        // ## Act ##
        ListResultBean&lt;Purchase&gt; purchaseList = purchaseBhv.selectList(cb -> {
            cb.setupSelect_Member().withMemberStatus();
            cb.setupSelect_Product();
            cb.query().queryMember().setBirthdate_IsNotNull();
            cb.query().addOrderBy_PurchaseDatetime_Desc();
            cb.query().addOrderBy_PurchasePrice_Desc();
            cb.query().addOrderBy_ProductId_Asc();
            cb.query().addOrderBy_MemberId_Asc();
        });

        // ## Assert ##
        assertHasAnyElement(purchaseList);
        purchaseList.forEach(purchase -> {
            Member member = purchase.getMember().get();
            MemberStatus status = member.getMemberStatus().get();
            Product product = purchase.getProduct().get();
            log(purchase.getProductId(), member.getMemberName(), status.getMemberStatusName(), product.getProductName(),
                    member.getMemberId());
        });
    }

    // TODO jflute ６番からまだやってない
}
</code></pre>
<!-- __content-end__ --></div></div>

<div id="sidebar">
	<ul>
		<li><a href="#">inu</a></li>
		<li><a href="#">neko</a></li>
	</ul>
</div>
<div id="footer">
	<ul>
		<li><a href="#">SiteMap</a></li>
		<li><a href="https://www.seasar.org/issues/browse/DBFLUTE">BTS</a></li>
		<li><a href="http://d.hatena.ne.jp/jflute">Author's Blog</a></li>
	</ul>
</div>
</div>
</body>
</html>