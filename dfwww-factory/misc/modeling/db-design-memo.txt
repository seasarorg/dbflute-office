[テーブル設計]

1. PrimaryKey設計

  1-1. 方式パターン

    A. 複合主キーを利用する

       o: 業務制約が付く
       o: カラム数が減る(サロゲートを利用しない分)
       x: SQLとの相性が悪い
       x: アプリとの相性が悪い
       x: 業務キーの構成変更に弱い
       x: テーブル間の依存性高い

    B. 必要に応じてサロゲートキー
       - 業務キーにユニーク制約を付与
       - 複合主キーのテーブルにサロゲートキー
       - 単一業務キーの変更要件のあるものにサロゲートキー
       - 区分値テーブルはコードキー(ex. char(3))

       o: 業務制約を付けたまま単一キーのメリットを享受
       o: SQLとの相性は良い
       o: アプリとの相性は良い(但し*1)
       o: 適材適所でメリットを享受
       v: 統一感はない
       x: Hibernate系のO/Rマッパとは相性悪い*1

    C. 全てのテーブルにサロゲートキー
       - 業務キーにユニーク制約を付与
       - 区分値テーブルもサロゲートキー(但し連番ではない)

       o: 業務制約を付けたまま単一キーのメリットを享受
       o: SQLとの相性は良い
       o: アプリとの相性は良い
       o: 統一感がある
       x: 「1は正式会員、2は仮会員」というようなわかりにくい区分値になる

  1-2. アンチパターン

    a. 主にJavaやC#などのアプリから利用するDBの場合の方式パターン「A」
    b. 業務キーにユニーク制約を付けないでサロゲートキーを付与
    c. 区分値テーブルのようなテーブルへのサロゲートキーを連番

  1-3. IDモデルとは？

    TODO: 俗に「IDモデル」と言った場合に「C」！？
 

2. 命名設計

  2-1. テーブル名

    2-1-1. 単語の連結

      2-1-1-1. 方式パターン

        A. ORDER_DETAIL
           o: どちらかというと一般的
           v: プログラム上の命名規則と不一致(但し不都合はあまりない)

        B. OrderDetail
           o: プログラム上の命名規則と一致

      2-1-1-2. アンチパターン

        A. 方式パターンの「A」と「B」が混在

    2-1-2. プレフィックス

      2-1-2-1. 方式パターン

        A. マスタ系トランザクション系で分ける「MST_/TRN_」
           o: ライフサイクルが見極め易い
           x: 境目が曖昧
           x: 少しテーブル名が長くなる

        B. 業務的なカテゴリで分ける「PRD_/MBR_」
           o: 業務的なカテゴリが見極め易い
           x: 命名が難しい
           x: 少しテーブル名が長くなる

        C. 特に何も付けない
           o: 命名に迷わない
           o: テーブル名が長くならない
           x: 特に名前で見極められるものがない

      2-1-2-2. アンチパターン

        a. 不統一なプレフィックス
        b. 間違ったプレフィックス

  TODO: 略語の付け方に関して
        バラバラの略語

・テーブル名を「複数形」にする
・予約語問題


  2-2. カラム名

    2-2-1. 単語の連結

      2-2-1-1. 方式パターン

        A. ORDER_DETAIL_ID
           o: どちらかというと一般的
           v: プログラム上の命名規則と不一致(但し不都合はあまりない)

        B. OrderDetailId
           o: プログラム上の命名規則と一致

    2-2-2. サロゲートキーのユニーク性

      2-2-2-1. 方式パターン

        A. シンプルで全てのサロゲートキーで同じ名前「ID」
           o: 統一感がある
           o: 書くのが楽
           v: プログラム上や会話する上で紛らわしいことがある

        B. テーブル名 + 「ID」
           o: 統一感がある
           o: 全てのおいてユニークなので紛らわしくない
           v: 書くのが大変(主に補完機能がない環境)

      2-2-2-2. アンチパターン

        a. 不統一なサロゲートキーのカラム名

    2-2-3. 名称カラムのユニーク性

      2-2-3-1. 方式パターン

        A. シンプルで全ての名称カラムで同じ名前「NAME」
           o: 統一感がある
           o: 書くのが楽
           x: プログラム上や会話する上で紛らわしいことがある
           x: 結合時などは結局「テーブル名+NAME」で扱うことになる

        B. テーブル名 + 「NAME」
           o: 統一感がある
           o: 全てにおいてユニークなので紛らわしくない
           v: 書くのが大変(主に補完機能がない環境)

      2-2-3-2. アンチパターン

        - 不統一な名称カラムのカラム名

  2-3. PrimaryKey制約名

    2-3-1. 方式パターン

      A. PK_ + テーブル名
         - 文字数制限に引っ掛かる場合は省略テーブル名を利用
         
         o: わかりやすい
         x: 文字数制限のあるDBの場合にDBAは常に意識する必要あり
         
      B. PK_ + システム連番
         - ERDツールなどによる自動生成

         o: 命名コストがない
         x: 非常にわかりにくい(一意制約違反発生時など)

    2-3-2. アンチパターン

      a. 手動で付与しているのにわかりにくい名称

  2-4. ForeignKey制約名

    2-4-1. 方式パターン

      A. FK_ + 自テーブル名 (+ 自カラム名)
         - 文字数制限に引っ掛かる場合は省略テーブル名を利用
         
         o: わかりやすい
         x: 文字数制限のあるDBの場合にDBAは常に意識する必要あり
         
      B. FK_ + システム連番
         - ERDツールなどによる自動生成

         o: 命名コストがない
         x: 非常にわかりにくい(FK制約違反発生時など)

    2-4-2. アンチパターン

      a. 手動で付与しているのにわかりにくい名称
      b. 「FK_ + 自テーブル名 + 相手テーブル名」だとマルチFKの場合にOUT

  2-5. Unique制約名

    PrimaryKey制約とほぼ同じ。
    但し、名称にカラム名を付与する場合あり：
      業務ユニークキー　：「UQ_ + テーブル名」
      その他ユニークキー：「UQ_ + テーブル名 + カラム名)」

  2-6. Index名
  
    Unique制約とほぼ同じ。
    プレフィックスは「IX_」。

3. NotNull設計

  3-1. 大前提

    NotNullであることが確定しているカラムに関しては必ず付与
    それにより、NotNull制約がそのまま「該当カラムのNull可否」を示すドキュメントになる

  3-2. ライフサイクルの違いによるNullable

    レコードのライフサイクルとカラムのライフサイクルの違いによって、
    NotNull制約を付与できない場合がある。例えば、とあるイベントが
    発生した時点でそのカラム値が確定する、というような場合は、
    レコードのInsert時にどうしてもNullを入れざるを得ない。
    その場合は、以下のような対応を視野に入れること：
    
      A. そのカラムをone-to-oneの別テーブルに出す
         o: もともとライフサイクルの違いで別テーブルであるべきだったかもしれない
         o: DBのフラグメンテーション防止に良い
         v: 結合が増える
         x: 存在確認のSQLが少々煩雑になる(existsなど)

      B. ダミー値を入れること
         o: nullはプログラム上でのバグのもと。
         o: 値がないこと(Null)で絞り込む際にIndexの恩恵を受けやすい
         x: 日付型や数値型でのダミー値定義は間違いを呼ぶ可能性あり。

  3-3. FKカラムのNullable
   
    FKカラムがNullableの場合、内部結合・外部結合で挙動が大きく変わるため、可能であれば以下のような対応を視野に入れること：
    
      A. 値がないこと(Null)を表すレコードをFK先テーブルに作成してFKカラムにNotNull制約を付与
         o: left outer joinとinner joinの挙動が同じになりミスが減る
         o: 値がないこと(Null)で絞り込む際にIndexの恩恵を受けやすい
         x: FK先がマスタ系テーブルで無い場合は適用しづらい。
    
4. カラムサイズ設計

  4-1. 大前提
  
    業務的にサイズが確定するものは、その通りのカラムサイズを設定する。

  4-2. サイズが曖昧なカラムに関して

    4-2-1. 「会員ID」などの連番カラム
    
      業務運用上オーバーフローしないように余裕をもったサイズにしておくこと。
      数値型の大きさでインフラ的な制約が出てくることはあまりないため、
      心配であればNumber(38)の利用も検討するのも一つの選択。

    4-2-2. 「会員名称」などの名称系カラム

      インフラ的な制約に引っかからない程度に余裕を持ったサイズにすること。
      (インフラ的な制約：SQLServerはレコード長が8Kまで)

5. リレーション

  5-1. one-to-manyの表現

    5-1-1. 方式パターン
    
      A. 素直にmany-to-oneの構造
         - many側がone側のPKに対してFKする

         o: 結合しやすい
         o: わかりやすくプログラマが迷わない
         v: 将来的なmany-to-manyへの変更が大変

      B. many-to-manyの構造でユニーク制約付与
         - 関連テーブルでmany側のFKカラムにユニーク制約付与

         v: 将来的なmany-to-many
         x: 結合が多くなる
         x: わかりにくくプログラマが迷う
            → ERDにユニーク制約の存在を強調ことである程度は解消

    *ライフサイクルの違いによる考慮

    5-1-2. アンチパターン

      - many-to-manyの構造でユニーク制約なし
        → 制約がないことで、不整合なデータが入る
        → 制約がないことで、プログラマが実装に迷う
    
  5-2. one-to-oneの表現
    
    one-to-oneに切り出す要素は以下：

      - ライフサイクルの違い
      - 意味的なわかりやすさ
      - 必要性の加減！？
      - テーブルのレコード長の膨張

    5-2-1. 方式パターン

      A. one-to-many構造でmany側でone側へのFKにユニーク制約(もしくはPFK)

         o: O/Rマッパとの相性が良い ※但し、Hibernateとの相性は悪い？(EAGERになってしまう)
         o: ライフサイクルの違いによる「NotNull制約の不可」がない
         v: 結合が必要になる

      B. many-to-one構造でmany側でone側へのFKにユニーク制約

         o: O/Rマッパとの相性が良い
         v: 結合が必要になる
         x: ライフサイクルの違いによる「NotNull制約の不可」がありえる
         x: ライフサイクルの違いによる都度都度基点テーブルの更新がありえる

      C. one-to-oneを利用せず一つのテーブルで表現

         o: 結合が不要
         x: O/Rマッパとの相性が悪い
         x: ライフサイクルの違いによる「NotNull制約の不可」がありえる
         x: レコード長が大きくなる可能性あり

6. 区分値

  6-1. 区分値テーブル
  
    6-1-1. 方式パターン
    
      A. 区分値ごとにテーブルを作成
      
         o: FK制約による制約が付与可能であり、かつ、厳密である
         o: 区分値毎の独自の情報(カラム)を追加しやすい
         o: ERD上で区分値を理解しやすい
         o: 区分の追加が簡単
         v: テーブル数が増える

      B. 一つのテーブルで区分値を全て管理

         o: テーブル数が増えない
         x: FK制約は付与できるが制約が厳密ではない(チェック制約で解消は可能)
         x: 区分値を表現するために複合キーが必要
         x: 区分値毎の独自の情報(カラム)が管理できない
         x: ERD上で区分値を理解しにくい(線を引くとぐちゃぐちゃになる)
         
      C. 特にテーブル管理せず

         o: テーブル数が増えない
         x: 制約が存在しない(チェック制約で解消は可能)
         x: 区分値毎の独自の情報(カラム)が管理できない
         x: ERD上で区分値を理解しにくい
         
     アンチパターン
         チェック制約なし「C」
         
  6-2. 区分値識別子の型

    6-2-1. 方式パターン
    
      A. 数値型(ex. integer)
      
         o: PKの数値型統一に貢献しやすい
         o: C#のENUMと相性が良い
         x: データ的に区分値の意味がわかりにくい

      B. 固定長文字列(ex. char(3))
      
         o: データ的に区分値の意味がわかりやすい
         o: パッと書けると意味がわかるの両方のいいとこ取り
         v: PKの数値型統一には貢献できない

      C. 可変長文字列(ex. varchar(20))
      
         o: データ的に区分値の意味がとてもわかりやすい
         v: PKの数値型統一には貢献できない
         v: 表現が長い可能性

9. ERDツール

  - EA
  - オブジェクトブラウザ
  - ERWin
  - E/R Studio
  
  - アンチパターン Visio